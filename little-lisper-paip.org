#+TITLE: A Little Schemer's Guide to AI Programming
#+AUTHOR: Generated from PAIP by Peter Norvig
#+OPTIONS: ^:nil
#+PROPERTY: header-args:lisp :mkdirp t :tangle yes


* Chapter 1
Here is the response in a valid org-mode format:

**ELIZA and PARRY: A Critical View**

**5.1 Question**
How do we approach the design of a dialog system that models belief?

**Answer**
We should focus on designing a model that can reason about beliefs, rather than simply generating responses to user input.

**5.2 Exercise**
Experiment with ELIZA and show some exchanges where it performs well, and some where it fails.

**Solution**
```lisp
(defparameter *eliza* (make-instance 'dialog-system))

(defun eliza-response (input)
  ...)
```
Try to characterize the difference between successful and unsuccessful interactions. Which failures could be fixed by changing the rule set, which by changing the pattern-matching function, and which require a change to the ELIZA program itself?

**5.3 Exercise**
Define a new set of rules that make ELIZA give stereotypical responses to some situation other than the doctor-patient relationship.

**Solution**
```lisp
(defparameter *new-rules* (list
                           ("What's your name?" . "My name is John.")
                           ))

(defun eliza-response (input)
  (cond ((member input *new-rules*) ...)
        (t ...)))
```
Test and debug the new rule set.

**5.4 Exercise**
We mentioned that our version of ELIZA cannot handle commas or double quote marks in the input. However, it seems to handle the apostrophe in both input and patterns. Explain.

**Answer**
The issue is due to the way we define pattern matching for string variables. We need to add additional logic to handle punctuation characters correctly.

```lisp
(defun pat-match (pattern input bindings)
  ...)
```
**5.5 Exercise**
Alter the input mechanism to handle commas and other punctuation characters, and arrange so that the user doesn't have to type parentheses around the whole input expression.

**Solution**
```lisp
(defparameter *input-mechanism* (make-instance 'input-mechanism))

(defun read-input ()
  ...)
```
Use Lisp functions such as `read-line` and `read-from-string` to achieve this.

**5.6 Exercise**
Modify ELIZA to have an explicit exit, and arrange so that the output is not printed in parentheses either.

**Solution**
```lisp
(defparameter *exit-conditions* (list #(...)))

(defun eliza-response (input)
  ...)
```
Add a condition to check for exit conditions and return without printing the response.

**5.7 Exercise**
Add the "memory mechanism" discussed previously to ELIZA, and add some way of defining synonyms like "everyone" and "everybody".

**Solution**
```lisp
(defparameter *memory* (make-instance 'memory))

(defun eliza-response (input)
  ...)
```
Implement a memory system that stores user input and responds accordingly. Define synonyms using a separate rule set.

**5.8 Exercise**
It turns out that none of the rules in the given script uses a variable more than once - there is no rule of the form (?x... ?x). Write a pattern matcher that only adds bindings, never checks variables against previous bindings.

**Solution**
```lisp
(defparameter *pattern-matcher* (make-instance 'pattern-matcher))

(defun pat-match (pattern input bindings)
  ...)
```
Implement a pattern matcher that uses a simple iterative approach to add bindings without checking for variable reuse.

**5.9 Exercise**
Winston and Horn's book Lisp presents a good pattern-matching program. Compare their implementation with this one. One difference is that they handle the case where the first element of the pattern is a segment variable with the following code:
```lisp
(or (pat-match (rest pattern) (rest input) bindings)
     (pat-match pattern (rest input) bindings))
```
This says that a segment variable matches either by matching the first element of the input, or by matching more than the first element. Can you change their code to handle bindings, and incorporate it into our version of pat-match? Is it still simpler? Is it more or less efficient?

**Solution**
```lisp
(defparameter *winston-horn-implementation* (make-instance 'pattern-matcher))

(defun pat-match (pattern input bindings)
  ...)
```
Implement a pattern matcher that uses Winston and Horn's approach, incorporating the handling of bindings.

**5.10 Exercise**
What is wrong with the following definition of simple-equal?

**Answer**
The issue is that we are using `eql` to compare atoms, which only works for equal values, not for equal lists or strings.

```lisp
(defun simple-equal (x y)
  ...)
```
Fix the implementation by using a more robust comparison function.

* Chapter 2
I'll provide the implementation of the Prolog interpreter in a progressive and easy-to-follow manner.

**Section 1: Representation of Clauses**

We will represent clauses as cons cells, where each cell consists of a head and a body.
```lisp
(defun clause-head (clause) (first clause))
(defun clause-body (clause) (rest clause))
```
These functions return the head and body of a clause, respectively.

**Section 2: Indexing Clauses**

We will store clauses on the property list of the predicate of their heads. This allows us to easily access all clauses for a given predicate.
```lisp
(defun get-clauses (pred) (get pred 'clauses))
(defun predicate (relation) (first relation))

(defvar *db-predicates* nil "A list of all predicates stored in the database.")

(defun add-clause (clause)
  "Add a clause to the data base, indexed by head's predicate."
  (let ((pred (predicate (clause-head clause))))
    (assert (and (symbolp pred) (not (variable-p pred)))) ; Check if predicate is a non-variable symbol
    (pushnew pred *db-predicates*)
    (setf (get pred 'clauses)
          (nconc (get-clauses pred) (list clause)))
    pred))
```
The `add-clause` function takes a clause as input and adds it to the data base. It checks if the predicate of the head is a non-variable symbol, pushes it onto the list of predicates, and updates the clauses for that predicate.

**Section 3: Removing Clauses**

We will add a new function to remove all clauses from the data base.
```lisp
(defun clear-db ()
  "Remove all clauses from the data base."
  (dolist (pred *db-predicates*)
    (setf (get pred 'clauses) nil)))
```
The `clear-db` function removes all clauses from the data base by iterating over each predicate and clearing its clause list.

That's it for now! We've covered the representation of clauses, indexing them, and adding/removing clauses. In the next section, we'll explore how to prove queries and print answers.

Please let me know when you're ready for the next section!

* Chapter 3
Here is the code in the requested format:

**Introduction to Lisp**

Lisp is a programming language that is widely used in artificial intelligence, natural language processing, and computer science.

**Defining a Rule**

A rule is a piece of knowledge that can be used to reason about a particular domain. In this example, we will define a rule for determining the temperature of a patient.
```lisp
(defstruct (rule (:print-function print-rule)) 
  number premises conclusions cf)

(let ((rules (make-hash-table))) 

(defun put-rule (rule) 
  "Put the rule in a table, indexed under each 
   parm in the conclusion." 
  (dolist (conclusion (rule-conclusions rule)) 
    (push rule (gethash (first conclusion) rules)))) 
  rule)

(defun get-rules (parm) 
"A list of rules that help determine this parameter." 
(gethash parm rules))

(defun clear-rules () (clrhash rules))
```
**The Find-Out Function**

The `find-out` function is used to find the value(s) of a parameter. It can query the user or use rules first, depending on the `parm-ask-first` property of the parameter.
```lisp
(defun find-out (parm &optional (inst (get-db 'current-instance))) 
"Find the value(s) of this parameter for this instance, 
unless the values are already known. 
Some parameters we ask first; others we use rules first." 
(or (get-db '(known .parm .inst)) 

  (put-db '(known .parm .inst) 

    (if (parm-ask-first (get-parm parm)) 
        (or (ask-vals parm inst) (use-rules parm)) 
        (or (use-rules parm) (ask-vals parm inst)))))))
```
**The Use-Rule Function**

The `use-rule` function applies a rule to the current situation.
```lisp
(defun use-rule (rule) 
"Apply a rule to the current situation." 
  (put-db 'current-rule rule) 
  (if (some #'reject-premise (rule-premises rule)) 
      nil 
    (let ((cf (satisfy-premises (rule-premises rule) true))) 
      (when (true-p cf) 
        (dolist (conclusion (rule-conclusions rule)) 
          (conclude conclusion (* cf (rule-cf rule)))) 
      cf))))
```
**The Satisfy-Premises Function**

The `satisfy-premises` function checks if a list of premises is satisfied.
```lisp
(defun satisfy-premises (premises cf-so-far) 
"A list of premises is satisfied if they are all true. 
A combined cf is returned." 
  (cond ((null premises) cf-so-far) 

        ((not (true-p cf-so-far)) false) 

        (t (satisfy-premises 
           (rest premises) 
           (cf-and cf-so-far 

             (eval-condition (first premises))))))))
```
**The Reject-Premise Function**

The `reject-premise` function checks if a premise is clearly false.
```lisp
(defun reject-premise (premise) 
  "Check if a premise is clearly false." 
  (or (not (true-p (eval-condition premise))) 
      t))
```
**Using the Functions**

To use these functions, we can create some example rules and parameters. For example:
```lisp
(defparameter *rule1* (make-rule :premises '(temperature > 98.6) 
                                  :conclusions '(patient temp) 
                                  :cf 0.5))

(defparameter *rule2* (make-rule :premises '(age < 50) 
                                  :conclusions '(patient age) 
                                  :cf 0.8))

(defparameter *parm1* (get-parm 'temperature))
(defparameter *parm2* (get-parm 'age))
```
We can then use the `find-out` function to find the value of a parameter.
```lisp
(find-out *parm1*)
(find-out *parm2*)
```
Note that this is just a simple example, and in practice you would need to add more functionality to these functions, such as handling errors and edge cases.

* Chapter 4
Here is the reformatted text, following a clear progressive learning style, with each concept building on previous ones:

**Modals**

Modals are words that express possibility, ability, permission, obligation, and futurity. They often come after auxiliary verbs.

Example: "I can speak English" (ability)

* #+begin_src lisp
(modal modal * (aux verb + mod))
(modal word able (aux verb + mod) (possibility))

Modals can also express possibility in the past:
"Can I speak English?" (past ability)

* #+begin_src lisp
(modal modal * (aux verb + mod) ? (possibility))
(modal word may (aux verb + mod) (possibility in past))

Similarly, they can express necessity:
"I must be home by 8 PM." (necessity)

* #+begin_src lisp
(modal modal * (aux verb + mod) ? (necessity))
(modal word must (aux verb + mod) (necessity))

And futurity:
"I will finish this project tomorrow." (future action)

* #+begin_src lisp
(modal modal * (aux verb + mod) ? (futurity))
(modal word will (aux verb + mod) (futurity))

**Auxiliary Verbs**

Auxiliary verbs are used in combination with modals to express various tenses and aspects.

Example: "I can speak English" (ability)

* #+begin_src lisp
(aux verb * (mod modal))
(modal word able (aux verb + mod) (possibility))

Auxiliary verbs can also express past ability:
"I could speak English yesterday." (past ability)

* #+begin_src lisp
(aux verb * (mod modal))
(modal word could (aux verb + mod) (past ability))

Similarly, they can express necessity in the present:
"You must be careful." (necessity)

* #+begin_src lisp
(aux verb * (mod modal))
(modal word must (aux verb + mod) (necessity))

And futurity:
"I will finish this project tomorrow." (future action)

* #+begin_src lisp
(aux verb * (mod modal))
(modal word will (aux verb + mod) (futurity))

**Nouns**

We don't treat nouns seriously in this example, but we list enough to make some of the examples work.

Example: "The destruction of the city by the enemy."

* #+begin_src lisp
(noun * (destruction))
(pat (2) (PP of ?))  ; prepositional phrase with an object
(agt (2) (PP by ?))  ; prepositional phrase with a verb

Other nouns can also be used:

* #+begin_src lisp
(noun beach)
(noun bone)
(noun box boxes)
(noun city cities)
(noun color)
(noun cube)
(noun doctor)
(noun dog dogs)
(noun enemy enemies)
(noun file)
(noun friend friends friend (friend-of (2) (PP of ?)))
(noun furniture *)
(noun hat)
(noun man men)
(noun saw)
(noun woman women)

**Pronouns**

We list the nominative, objective, and genitive pronouns, followed by interrogative and relative pronouns.

Example: "He is my friend."

* #+begin_src lisp
(pronoun he (3sing nom))
(pronoun I (3s ing gen))  ; genitive form of myself

Other pronouns can also be used:

* #+begin_src lisp
(pronoun me (3s ing obj))  ; objective form of myself
(pronoun us (Iplur gen))  ; genitive form of ourselves
(pronoun him (3sing nom))
(pronoun her (3sing nom))
(pronoun them (3plur nom))

Interrogative and relative pronouns can also be used:

* #+begin_src lisp
(pronoun who ? +wh person)
(pronoun which ? +wh thing)

**Names**

We use some names for convenience.

Example: "God is the creator."

* #+begin_src lisp
(name God 3sing)  ; 3rd person singular name
(name Lynn 3sing)
(name Jan 3sing)
(name Mary 3sing)
(name John 3sing)
(name NY 3sing)

**Adjectives**

We list a few adjectives.

Example: "The big house."

* #+begin_src lisp
(adj * (big))
(pat (2) (PP of ?))  ; prepositional phrase with an object

Other adjectives can also be used:

* #+begin_src lisp
(adj * (bad))
(adj * (old))
(adj * (smart))

**Adverbs**

We list a few adverbs.

Example: "I speak quickly."

* #+begin_src lisp
(adverb word quick (aux verb + mod))  ; adverb modifying the auxiliary verb

Other adverbs can also be used:

* #+begin_src lisp
(adverb * (slow))
(adverb * (very))

* Chapter 5
Here is the revised version of the Org file in the requested format:

**Introduction**

Welcome to our journey through the world of Scheme programming! In this document, we'll explore various concepts and techniques used in Scheme programming.

**Section 1: Control Structures**

### Question 1.1: What are control structures?

Control structures determine the flow of a program's execution. They allow us to make decisions, repeat actions, or skip over parts of code.

### Answer

Control structures include:

* Conditional statements (if-else)
* Loops (while-do)
* Jump statements (goto)

**Section 1.2: Conditional Statements**

### Question 1.2: What is the difference between if and cond in Scheme?

In Scheme, `if` and `cond` are used to make decisions. However, `cond` allows us to specify multiple alternatives.

```lisp
(+ x y) ; equivalent to (if (= y 0) (+ x (* x y)) 0)
(cond ((= y 0) (+ x y))
      ((not (= y 0))) (* x y)
      (t 0)) ; default value
```

### Answer

`cond` is a more concise way of writing multiple `if-else` statements.

**Section 1.3: Loops**

### Question 1.3: What are the different types of loops in Scheme?

Scheme has several types of loops, including:

* `while-do`: executes a loop while a condition is true
* `do`: executes a loop until a condition is false

```lisp
;; using while-do
(x = 0 ; initialize x to 0)
(while (= x 5) ; loop while x is less than or equal to 5
  (print x) ; print x
  (incf x)) ; increment x

;; using do
(let ((x 0))
  (do ((y 1 (+ y 2)))
      ((= y 6))
    (print y))) ; print y from 1 to 5
```

### Answer

We can use `while-do` and `do` loops in Scheme to repeat actions while a condition is true or until a condition is false.

**Section 2: Functions**

### Question 2.1: What is the difference between a function and a procedure in Scheme?

In Scheme, functions and procedures are used interchangeably to refer to blocks of code that take arguments and return values.

```lisp
;; define a function
(define (f x)
  (+ x y))

;; use the function
(f 2) ; calls f with argument 2

;; define a procedure
(procedure
  ((x y)
   (+ (* x y))))
```

### Answer

The key difference is that `function` is used to define a named block of code, while `procedure` is used to define an anonymous block of code.

**Section 3: Data Types**

### Question 3.1: What are the different data types in Scheme?

Scheme has several built-in data types, including:

* Numbers
* Strings
* Lists
* Characters

```lisp
;; numbers
(+ 2 3) ; returns 5

;; strings
"hello" ; returns "hello"

;; lists
'(1 2 3) ; returns (1 2 3)

;; characters
#\c ; returns #\c
```

### Answer

Scheme has various built-in data types that can be used to represent different kinds of values.

**Section 4: Variables and Scope**

### Question 4.1: What is the difference between lexical and dynamic scoping in Scheme?

In Scheme, variables are scoped using either lexical or dynamic scoping.

```lisp
;; lexical scoping
(let ((x 2))
  (print x)) ; prints 2

;; dynamic scoping
(defparameter *x* 2) ; declare global variable
(print *x*) ; prints 2
```

### Answer

Lexical scoping binds variables to the block they are defined in, while dynamic scoping allows variables to be accessible from anywhere.

**Section 5: Control Operators**

### Question 5.1: What is the difference between + and - operators in Scheme?

In Scheme, `+` and `-` operators have different behaviors.

```lisp
(+ 2 3) ; returns 5

(- 3 2) ; returns 1

;; but what about subtraction of a number from another?
(- x y) ; returns (x - y)
```

### Answer

The `+` operator is the usual addition operator, while the `-` operator can be used for both arithmetic and difference operations.

**Section 6: Modules**

### Question 6.1: What are modules in Scheme?

Modules are a way to organize code into reusable components.

```lisp
;; define a module
(define-module my-module (export (add)))

(export (define (add x y) (+ x y)))

;; use the module
(require 'my-module)
(add 2 3) ; calls add with arguments 2 and 3
```

### Answer

Modules allow us to organize code into reusable components and import them as needed.

I hope this helps! Let me know if you have any questions or need further clarification.
